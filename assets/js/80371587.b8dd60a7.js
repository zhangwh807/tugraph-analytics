"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6120],{2830:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var t=r(4848),a=r(8453);const i={},s="Graph Traversal Introduction",l={id:"application-development/api/graph/traversal",title:"Graph Traversal Introduction",description:"GeaFlow provides interfaces for implementing graph traversal algorithms, which can be used for subgraph traversal and full graph traversal. Users can choose to continue traversing vertices or edges in the traversal algorithm and define the number of iterations.",source:"@site/../docs-en/source/5.application-development/1.api/3.graph/1.traversal.md",sourceDirName:"5.application-development/1.api/3.graph",slug:"/application-development/api/graph/traversal",permalink:"/tugraph-analytics/en/application-development/api/graph/traversal",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sink Introduction",permalink:"/tugraph-analytics/en/application-development/api/stream/sink"},next:{title:"Graph Compute Introduction",permalink:"/tugraph-analytics/en/application-development/api/graph/compute"}},o={},p=[{value:"Dynamic Graph",id:"dynamic-graph",level:2},{value:"Interface",id:"interface",level:3},{value:"Example",id:"example",level:3},{value:"Statical Graph",id:"statical-graph",level:2},{value:"Interface",id:"interface-1",level:3},{value:"Example",id:"example-1",level:3}];function c(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"graph-traversal-introduction",children:"Graph Traversal Introduction"})}),"\n",(0,t.jsx)(n.p,{children:"GeaFlow provides interfaces for implementing graph traversal algorithms, which can be used for subgraph traversal and full graph traversal. Users can choose to continue traversing vertices or edges in the traversal algorithm and define the number of iterations."}),"\n",(0,t.jsx)(n.h2,{id:"dynamic-graph",children:"Dynamic Graph"}),"\n",(0,t.jsx)(n.h3,{id:"interface",children:"Interface"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"API"}),(0,t.jsx)(n.th,{children:"Interface Description"}),(0,t.jsx)(n.th,{children:"Input Parameter Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void open(IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext)"}),(0,t.jsx)(n.td,{children:"Perform the open operation of vertexCentricFunction"}),(0,t.jsx)(n.td,{children:"vertexCentricFuncContext: where K represents the type of vertex ID, VV represents the type of vertex value, EV represents the type of edge value, M represents the type of message defined in graph traversal, and R represents the type of traversal result"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void init(ITraversalRequest traversalRequest)"}),(0,t.jsx)(n.td,{children:"Graph traversal initialization interface"}),(0,t.jsx)(n.td,{children:"traversalRequest: Trigger vertices for graph traversal, where K represents the type of vertex ID"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph)"}),(0,t.jsx)(n.td,{children:"Implement processing logic for incremental graph during the first round of computation"}),(0,t.jsxs)(n.td,{children:["vertexId: ID of the current computing vertex, where K represents the type of vertex ID. ",(0,t.jsx)(n.br,{}),"temporaryGraph: Temporary incremental graph, where K represents the type of vertex ID, VV represents the type of vertex value, and EV represents the type of edge value"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void compute(K vertexId, Iterator messageIterator)"}),(0,t.jsx)(n.td,{children:"Graph traversal interface"}),(0,t.jsxs)(n.td,{children:["vertexId: ID of the current computing vertex, where K represents the type of vertex ID. ",(0,t.jsx)(n.br,{}),"messageIterator: All messages sent to the current vertex during graph traversal, where M represents the type of message defined in the traversal iteration process"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph)"}),(0,t.jsx)(n.td,{children:"Graph traversal complete interface"}),(0,t.jsxs)(n.td,{children:["vertexId: ID of the current computing vertex, where K represents the type of vertex ID. ",(0,t.jsx)(n.br,{}),"mutableGraph: Mutable graph, where K represents the type of vertex ID, VV represents the type of vertex value, and EV represents the type of edge value"]})]})]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Detailed interface"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"   public interface IncVertexCentricTraversalFunction<K, VV, EV, M, R> extends IncVertexCentricFunction<K, VV\n   , EV, M> {\n\n   void open(IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext);\n\n   void init(ITraversalRequest<K> traversalRequest);\n\n   void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph);\n\n   void compute(K vertexId, Iterator<M> messageIterator);\n\n   void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph);\n\n   interface IncVertexCentricTraversalFuncContext<K, VV, EV, M, R> extends IncGraphContext<K, VV, EV,\n   M> {\n   /** Activate traversal starting point for use in the following iteration. */\n   void activeRequest(ITraversalRequest<K> request);\n   /** Collect traversal results. */\n   void takeResponse(ITraversalResponse<R> response);\n\n        void broadcast(IGraphMessage<K, M> message);\n    \t/** Get historical graph data. */\n        TraversalHistoricalGraph<K, VV, EV> getHistoricalGraph();\n   }\n\n\n    interface TraversalHistoricalGraph<K, VV, EV>  extends HistoricalGraph<K, VV, EV> {\n    \t/** Get the snapshot of specified version. */\n        TraversalGraphSnapShot<K, VV, EV> getSnapShot(long version);\n    }\n\n    interface TraversalGraphSnapShot<K, VV, EV> extends GraphSnapShot<K, VV, EV> {\n    \t/** Get the starting vertex for graph traversal. */\n        TraversalVertexQuery<K, VV> vertex();\n    \t/** Get the starting edge for graph traversal. */\n        TraversalEdgeQuery<K, EV> edges();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class IncrGraphTraversalAll {\n\n    private static final Logger LOGGER =\n        LoggerFactory.getLogger(IncrGraphTraversalAll.class);\n    \n    public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        String graphName = "graph_view_name";\n        GraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName)\n            .withShardNum(2)\n            .withBackend(BackendType.RocksDB)\n            .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n            .build();\n        pipeline.withView(graphName, graphViewDesc);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                PWindowSource<IVertex<Integer, Integer>> vertices =\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>("data/input/email_edge",\n                            line -> {\n                                String[] fields = line.split(",");\n                                IVertex<Integer, Integer> vertex1 = new ValueVertex<>(\n                                    Integer.valueOf(fields[0]), 1);\n                                IVertex<Integer, Integer> vertex2 = new ValueVertex<>(\n                                    Integer.valueOf(fields[1]), 1);\n                                return Arrays.asList(vertex1, vertex2);\n                            }), SizeTumblingWindow.of(10000));\n                \n                PWindowSource<IEdge<Integer, Integer>> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>("data/input/email_edge",\n                        line -> {\n                            String[] fields = line.split(",");\n                            IEdge<Integer, Integer> edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                Integer.valueOf(fields[1]), 1);\n                            return Collections.singletonList(edge);\n                        }), SizeTumblingWindow.of(5000));\n\n                PGraphView<Integer, Integer, Integer> fundGraphView =\n                    pipelineTaskCxt.getGraphView(graphName);\n                PIncGraphView<Integer, Integer, Integer> incGraphView =\n                    fundGraphView.appendGraph(vertices, edges);\n                incGraphView.incrementalTraversal(new IncGraphTraversalAlgorithms(3))\n                    .start()\n                    .sink(v -> {});\n            }\n        });\n        IPipelineResult result = pipeline.execute();\n        result.get();\n    }\n    \n    public static class IncGraphTraversalAlgorithms extends IncVertexCentricTraversal<Integer,\n            Integer, Integer, Integer, Integer> {\n        \n        public IncGraphTraversalAlgorithms(long iterations) {\n            super(iterations);\n        }\n        \n        @Override\n        public IncVertexCentricTraversalFunction<Integer, Integer, Integer, Integer, Integer> getIncTraversalFunction() {\n            return new IncVertexCentricTraversalFunction<Integer, Integer, Integer, Integer, Integer>() {\n\n                private IncVertexCentricTraversalFuncContext<Integer, Integer, Integer, Integer, Integer> vertexCentricFuncContext;\n\n                @Override\n                public void open(IncVertexCentricTraversalFuncContext<Integer, Integer, Integer, Integer,\n                    Integer> vertexCentricFuncContext) {\n                    this.vertexCentricFuncContext = vertexCentricFuncContext;\n                }\n\n                @Override\n                public void evolve(Integer vertexId,\n                                   TemporaryGraph<Integer, Integer, Integer> temporaryGraph) {\n                    MutableGraph<Integer, Integer,\n                        Integer> mutableGraph = this.vertexCentricFuncContext.getMutableGraph();\n                    IVertex<Integer, Integer> vertex = temporaryGraph.getVertex();\n                    if (vertex != null) {\n                        mutableGraph.addVertex(0, vertex);\n                    }\n                    List<IEdge<Integer, Integer>> edges = temporaryGraph.getEdges();\n                    if (edges != null) {\n                        for (IEdge<Integer, Integer> edge : edges) {\n                            mutableGraph.addEdge(0, edge);\n                        }\n                    }\n                }\n\n                @Override\n                public void init(ITraversalRequest<Integer> traversalRequest) {\n                    int requestId = traversalRequest.getVId();\n                    List<IEdge<Integer, Integer>> edges =\n                        this.vertexCentricFuncContext.getHistoricalGraph().getSnapShot(0).edges().getEdges();\n                    int sum = 0;\n                    if (edges != null) {\n                        for (IEdge<Integer, Integer> edge : edges) {\n                            sum += edge.getValue();\n                        }\n                    }\n                    this.vertexCentricFuncContext.takeResponse(new TraversalResponse(requestId, sum));\n                }\n\n                @Override\n                public void compute(Integer vertexId, Iterator<Integer> messageIterator) {\n                }\n\n                @Override\n                public void finish(Integer vertexId,\n                                   MutableGraph<Integer, Integer, Integer> mutableGraph) {\n                }\n            };\n        }\n        @Override\n        public VertexCentricCombineFunction<Integer> getCombineFunction() {\n            return null;\n        }\n    }\n\n    static class TraversalResponse implements ITraversalResponse<Integer> {\n\n        private long responseId;\n\n        private int value;\n\n        public TraversalResponse(long responseId, int value) {\n            this.responseId = responseId;\n            this.value = value;\n        }\n        @Override\n        public long getResponseId() {\n            return responseId;\n        }\n        @Override\n        public Integer getResponse() {\n            return value;\n        }\n        @Override\n        public ResponseType getType() {\n            return ResponseType.Vertex;\n        }\n        @Override\n        public String toString() {\n            return responseId + "," + value;\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"statical-graph",children:"Statical Graph"}),"\n",(0,t.jsx)(n.h3,{id:"interface-1",children:"Interface"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"API"}),(0,t.jsx)(n.th,{children:"Interface Description"}),(0,t.jsx)(n.th,{children:"Input Parameter Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void open(VertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext)"}),(0,t.jsx)(n.td,{children:"Perform open operation using vertexCentric function"}),(0,t.jsx)(n.td,{children:"vertexCentricFuncContext: K represents the type of vertex ID, VV represents the type of vertex value, EV represents the type of edge value, M represents the type of message defined in graph traversal, and R represents the type of traversal result"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void init(ITraversalRequest traversalRequest)"}),(0,t.jsx)(n.td,{children:"Graph traversal initialization interface"}),(0,t.jsx)(n.td,{children:"Traversal request: Graph traversal trigger vertex, where K represents the type of vertex ID"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"void compute(K vertexId, Iterator messageIterator)"}),(0,t.jsx)(n.td,{children:"Graph traversal interface"}),(0,t.jsxs)(n.td,{children:["vertexId: ID of the current computing vertex, where K represents the type of vertex ID. ",(0,t.jsx)(n.br,{}),"messageIterator: All messages sent to the current vertex during graph traversal, where M represents the type of message defined in the traversal iteration process"]})]})]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Detailed interface"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public interface VertexCentricTraversalFunction<K, VV, EV, M, R> extends VertexCentricFunction<K, VV\n    , EV, M> {\n\n    void open(VertexCentricTraversalFuncContext<K, VV, EV, M, R> vertexCentricFuncContext);\n\t/** Graph traversal algorithm initialization method. */\n    void init(ITraversalRequest<K> traversalRequest);\n\t/** Implement graph traversal logic. */\n    void compute(K vertexId, Iterator<M> messageIterator);\n\n    void finish();\n\n    void close();\n\t\n    interface VertexCentricTraversalFuncContext<K, VV, EV, M, R> extends VertexCentricFuncContext<K,\n        VV, EV, M> {\n    \t/** Retrieve graph traversal results. */\n        void takeResponse(ITraversalResponse<R> response);\n    \t/** Get the starting vertex for graph traversal. */\n        TraversalVertexQuery<K, VV> vertex();\n    \t/** Get the starting edges for graph traversal. */\n        TraversalEdgeQuery<K, EV> edges();\n\n        void broadcast(IGraphMessage<K, M> message);\n    }\n\n    interface TraversalVertexQuery<K, VV> extends VertexQuery<K, VV> {\n    \t/** Retrieve iterator of vertices in graph traversal. */\n        Iterator<K> loadIdIterator();\n    }\n\n    interface TraversalEdgeQuery<K, EV> extends EdgeQuery<K, EV> {\n    \t/** Retrieve the corresponding graph traversal starting vertices by specifying the vertex ID. */\n        TraversalEdgeQuery<K, EV> withId(K vertexId);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class StaticGraphTraversalAllExample {\n    private static final Logger LOGGER =\n            LoggerFactory.getLogger(StaticGraphTraversalAllExample.class);\n\n    public static void main(String[] args) {\n        Environment environment = EnvironmentFactory.onLocalEnvironment();\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n        pipeline.submit(new PipelineTask() {\n            @Override\n            public void execute(IPipelineTaskContext pipelineTaskCxt) {\n                PWindowSource<IVertex<Integer, Integer>> prVertices =\n                        pipelineTaskCxt.buildSource(new FileSource<>("data/input/email_vertex",\n                                line -> {\n                                    String[] fields = line.split(",");\n                                    IVertex<Integer, Integer> vertex = new ValueVertex<>(Integer.valueOf(fields[0]),\n                                            Integer.valueOf(fields[1]));\n                                    return Collections.singletonList(vertex);\n                                }), AllWindow.getInstance()).withParallelism(1);\n\n                PWindowSource<IEdge<Integer, Integer>> prEdges =\n                        pipelineTaskCxt.buildSource(new FileSource<>("data/input/email_edge",\n                                line -> {\n                                    String[] fields = line.split(",");\n                                    IEdge<Integer, Integer> edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                            Integer.valueOf(fields[1]), 1);\n                                    return Collections.singletonList(edge);\n                                }), AllWindow.getInstance()).withParallelism(1);\n\n                GraphViewDesc graphViewDesc = GraphViewBuilder\n                        .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n                        .withShardNum(1)\n                        .withBackend(BackendType.Memory)\n                        .build();\n\n                PGraphWindow<Integer, Integer, Integer> graphWindow =\n                        pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n\n                graphWindow.traversal(new VertexCentricTraversal<Integer, Integer, Integer, Integer, Integer>(3) {\n                    @Override\n                    public VertexCentricTraversalFunction<Integer, Integer, Integer, Integer,\n                            Integer> getTraversalFunction() {\n                        return new VertexCentricTraversalFunction<Integer, Integer, Integer, Integer, Integer>() {\n\n                            private VertexCentricTraversalFuncContext<Integer, Integer, Integer, Integer, Integer> vertexCentricFuncContext;\n\n                            @Override\n                            public void open(\n                                    VertexCentricTraversalFuncContext<Integer, Integer, Integer, Integer, Integer> vertexCentricFuncContext) {\n                                this.vertexCentricFuncContext = vertexCentricFuncContext;\n                            }\n\n                            @Override\n                            public void init(ITraversalRequest<Integer> traversalRequest) {\n                                this.vertexCentricFuncContext.takeResponse(\n                                        new TraversalResponse(traversalRequest.getRequestId(), 1));\n                            }\n                            @Override\n                            public void compute(Integer vertexId, Iterator<Integer> messageIterator) {\n                            }\n                            @Override\n                            public void finish() {\n                            }\n                            @Override\n                            public void close() {\n                            }\n                        };\n                    }\n\n                    @Override\n                    public VertexCentricCombineFunction<Integer> getCombineFunction() {\n                        return null;\n                    }\n                }).start().sink(v -> {});\n            }\n        });\n\n        IPipelineResult result = pipeline.execute();\n        result.get();\n    }\n    public static class TraversalResponse implements ITraversalResponse<Integer> {\n        private long responseId;\n        private int response;\n        public TraversalResponse(long responseId, int response) {\n            this.responseId = responseId;\n            this.response = response;\n        }\n\n        @Override\n        public long getResponseId() {\n            return responseId;\n        }\n\n        @Override\n        public Integer getResponse() {\n            return response;\n        }\n\n        @Override\n        public ResponseType getType() {\n            return ResponseType.Vertex;\n        }\n\n        @Override\n        public String toString() {\n            return "TraversalResponse{" + "responseId=" + responseId + ", response=" + response\n                    + \'}\';\n        }\n    }\n\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>l});var t=r(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);