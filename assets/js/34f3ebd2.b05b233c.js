"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9804],{3166:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/state_type-d6781576f91671f15511f483ffeda59d.png"},6213:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/state_arch_new-d419a2e40116f97094862b53bebaf776.png"},8370:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/state_flow-1d20c7f8a4157ef55cc8ba4579ca9391.png"},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var n=a(6540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},9591:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=a(4848),i=a(8453);const s={},r="Introduction to State Principles",o={id:"concepts/state_principle",title:"Introduction to State Principles",description:"State Management in Geaflow",source:"@site/../docs-en/source/4.concepts/4.state_principle.md",sourceDirName:"4.concepts",slug:"/concepts/state_principle",permalink:"/tugraph-analytics/en/concepts/state_principle",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Framework Architecture",permalink:"/tugraph-analytics/en/concepts/framework_principle"},next:{title:"GeaFlow Console Platform",permalink:"/tugraph-analytics/en/concepts/console_principle"}},c={},l=[{value:"State Management in Geaflow",id:"state-management-in-geaflow",level:2},{value:"State Architecture",id:"state-architecture",level:3},{value:"State Operational Process",id:"state-operational-process",level:2},{value:"State Creation",id:"state-creation",level:3},{value:"State Read and Write",id:"state-read-and-write",level:3},{value:"State Persistency",id:"state-persistency",level:3},{value:"State Recovery",id:"state-recovery",level:3},{value:"The Types of State",id:"the-types-of-state",level:2},{value:"Graph State",id:"graph-state",level:3},{value:"Static Graph State",id:"static-graph-state",level:4},{value:"Dynamic Graph State",id:"dynamic-graph-state",level:4},{value:"Key State",id:"key-state",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"introduction-to-state-principles",children:"Introduction to State Principles"})}),"\n",(0,n.jsx)(t.h2,{id:"state-management-in-geaflow",children:"State Management in Geaflow"}),"\n",(0,n.jsx)(t.p,{children:"In Geaflow, state refers to the intermediate calculation results of directly calculated nodes during graph and flow computation processes. This intermediate result may be organized source data information or some results generated by calculation. State management is responsible for the storage and access of this data as well as consistency assurance. As the central data hub of Geaflow, its functional model, performance, and reliability directly affect the entire use process of Geaflow, and it is the foundation of the entire system."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"In terms of the function, it supports Geaflow's real-time, multi-mode dynamic graph engine, including low-latency flow graph fusion computation, high-performance long-cycle graph simulation, large-scale dynamic graph exploration, and more."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"In terms of the computation model, the state management in Geaflow belongs to the combination of real-time model and graph model. It needs to overcome the processing mechanism with state in real-time computing, low latency, fault tolerance, and recovery mechanisms. Additionally, it also needs to solve the problems of complex data, high association, data-driven computation, and large intermediate results in graph models."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"In terms of performance, state management needs to solve the problem of achieving high throughput and low-latency storage and query capabilities under the premise of low cost, multiple scenarios, and large-scale data. This includes accessing data at the scale of trillions of edges, accessing larger attribute information, and random and traversal access with multiple pushdown semantics."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Therefore, we have the following architecture diagram, which is flexible and supports multiple pluggable components."}),"\n",(0,n.jsx)(t.h3,{id:"state-architecture",children:"State Architecture"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"state_arch",src:a(6213).A+"",width:"2232",height:"446"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"State API"}),": Provides an API for key-value storage operations, such as get/put/delete. It also provides APIs for graph storage, such as V/E/VE, and operations for adding/updating/deleting vertices and edges."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"State Execution Layer"}),": Implements data sharding and scalability through the design of KeyGroups. Accessor provides IO abstractions for different read/write strategies and data models. StateOperator abstracts the storage layer SPI, including operations like finish (flushing to disk), archive (checkpoint), compact (compression), recover (recovery), etc. Additionally, State provides various pushdown optimizations to accelerate IO access efficiency. Customized memory management and attribute-based secondary indexing are also provided for storage access optimization."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Store Layer"}),": GeaFlow supports multiple types of storage systems and encapsulates schemas, serializers, and\ndata version information through StoreContext. This layer deals with how in-memory data structures are mapped to storage structures. Currently, storage engines include Redis, Rocksdb (GeaFlow's proprietary storage system), which provide services through SPI. Depending on the characteristics of the storage engine, they may support different data models. For example, all data structures in Rocksdb need to be mapped to key-value pairs, while Redis inherently provides advanced data structures like lists/maps."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Persistence Layer"}),": GeaFlow State itself does not provide persistence capability. If a machine failure or disk corruption occurs, data loss may happen. Therefore, it relies on external components to provide persistence storage. These components are also pluggable and can support distributed file storage or object storage, such as HDFS/OSS/S3, etc."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"state-operational-process",children:"State Operational Process"}),"\n",(0,n.jsx)(t.p,{children:"The life of State shows below:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"state_flow",src:a(8370).A+"",width:"1429",height:"487"})}),"\n",(0,n.jsx)(t.p,{children:"When failOver happens, it will recover from the last persistent data. The following is the detailed process."}),"\n",(0,n.jsx)(t.h3,{id:"state-creation",children:"State Creation"}),"\n",(0,n.jsx)(t.p,{children:"The data processed by State is already divided into each partition dimension by the framework layer."}),"\n",(0,n.jsx)(t.p,{children:"All State requests go through the StateFactory, and different States can be requested based on different Descriptors."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"buildGraphState(GraphStateDescriptor, Configuration):GraphState\nbuildKeyValueState(KeyValueStateDescriptor, Configuration):KeyValueState\nbuildKeyListState(KeyListDescriptor, Configuration):KeyListState\nbuildKeyMapState(KeyMapStateDescriptor, Configuration):KeyMapState\n"})}),"\n",(0,n.jsx)(t.p,{children:"The Descriptor needs to declare basic information, including State name, Store type, etc. Different State names correspond to isolated States, and different States can be requested to represent different scenarios. For example, a Memory Store State can be requested as a temporary storage or calculation intermediate."}),"\n",(0,n.jsx)(t.p,{children:"The choice of Store type is closely related to storage performance. For example, for Key State, if the underlying Store supports the KMap method, it will directly use the functions of KMap, which can perform incremental subkey operations. If it does not support KMap, it will be converted to a KV-model State, and the entire Map will be operated on, which will greatly magnify the size of both read and write operations."}),"\n",(0,n.jsx)(t.p,{children:"After creation, we also need to read and write to the State."}),"\n",(0,n.jsx)(t.h3,{id:"state-read-and-write",children:"State Read and Write"}),"\n",(0,n.jsx)(t.p,{children:"Depending on the different types of State requested as mentioned above, they have different ways of reading and writing, which will be discussed in the end of the document."}),"\n",(0,n.jsx)(t.h3,{id:"state-persistency",children:"State Persistency"}),"\n",(0,n.jsx)(t.p,{children:"In a computing task, if there is an exceptional circumstance such as a machine failure, the state data stored on the disk can be lost. To enable normal rollback, State also needs to consider the ability of persistence, so that the machine that is reassigned can retrieve the State data and continue computing."}),"\n",(0,n.jsx)(t.p,{children:"In each computing task, users need to periodically do a checkpoint to persist the data and ensure the safety of the state data. This can be done after a batch of tasks is completed, or after the derivative task is completed. The timing of the checkpoint should be consistent with the source offset. Only when both the state checkpoint and source offset are saved, can it be considered that all state data of this job has been persisted."}),"\n",(0,n.jsx)(t.h3,{id:"state-recovery",children:"State Recovery"}),"\n",(0,n.jsx)(t.p,{children:"When an exception occurs, the framework layer will perform FailOver, and State will automatically roll back to the latest state. Depending on the choice of the persistence layer as mentioned above, State data will be retrieved and loaded from the corresponding distributed file storage or object storage."}),"\n",(0,n.jsx)(t.h2,{id:"the-types-of-state",children:"The Types of State"}),"\n",(0,n.jsx)(t.p,{children:"State can be roughly divided into Graph State and Key State, corresponding to different data structures and mapping to different storage models in the Store layer. For example, for the store type of Rocksdb, there will be different types of storage models such as KV and Graph."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"state_type",src:a(3166).A+"",width:"916",height:"445"})}),"\n",(0,n.jsx)(t.h3,{id:"graph-state",children:"Graph State"}),"\n",(0,n.jsx)(t.p,{children:"Graph State can be further classified into StaticGraph and DynamicGraph, based on whether it is a dynamic graph or not.\nThe difference is that StaticGraph treats the entire graph as a complete one, and all operations are performed on the complete graph.\nOn the other hand, DynamicGraph considers the graph to be dynamic, consisting of slice graphs that form a complete graph."}),"\n",(0,n.jsx)(t.h4,{id:"static-graph-state",children:"Static Graph State"}),"\n",(0,n.jsx)(t.p,{children:"StaticGraphState API is divided into several parts, including query, upsert, delete, and manage."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"query: Graph query, which allows users to flexibly query GraphState from multiple dimensions such as nodes, edges, nodes and outbound edges. It can be a random or global query, and different pushdown conditions can be added. The final return value can be an iterator or a list."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"upsert: Adding nodes or edges."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"delete: Deleting a certain node or ID."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"manage: Divided into operator and other operations. Operator is the data operation of the State, which can perform flushing persistence or recovery. Other operations include obtaining information such as summary and metrics."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"dynamic-graph-state",children:"Dynamic Graph State"}),"\n",(0,n.jsx)(t.p,{children:"DynamicGraphState API is similar to StaticGraphState, but each node and edge is associated with a version number."}),"\n",(0,n.jsx)(t.p,{children:"At the same time, Dynamic Graph State also adds version-related queries, which can obtain all versions or the latest version corresponding to certain nodes, and can obtain the specific values of each version."}),"\n",(0,n.jsx)(t.h3,{id:"key-state",children:"Key State"}),"\n",(0,n.jsx)(t.p,{children:"KeyState API is divided into several parts, including:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"KeyValueState"}),"\n",(0,n.jsx)(t.li,{children:"KeyListState"}),"\n",(0,n.jsx)(t.li,{children:"KeyMapState"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Each corresponds to a different user-level data structure. Similar to GraphState, KeyState also provides the ability to query, upsert, delete, and manage, but the query does not provide complex query semantic information like GraphState. Different State data structures have differences in querying and storage. For example, KMap allows modification and querying of a single subkey, while KV modifies and queries the entire value."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);