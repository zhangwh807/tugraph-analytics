"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9163],{543:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/dsl_arch_new-e204f440b92d2a29fd8f9edf65fdab7b.png"},844:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/dsl_twice_level_dag-b2702bc03a59d5eee046d7dba5c7ed15.png"},3723:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var i=n(4848),o=n(8453);const a={},s="DSL Principle Introduction",r={id:"concepts/dsl_principle",title:"DSL Principle Introduction",description:"GeaFlow DSL Architecture",source:"@site/../docs-en/source/4.concepts/2.dsl_principle.md",sourceDirName:"4.concepts",slug:"/concepts/dsl_principle",permalink:"/tugraph-analytics/en/concepts/dsl_principle",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Glossary",permalink:"/tugraph-analytics/en/concepts/glossary"},next:{title:"Framework Architecture",permalink:"/tugraph-analytics/en/concepts/framework_principle"}},l={},c=[{value:"GeaFlow DSL Architecture",id:"geaflow-dsl-architecture",level:2},{value:"Main Execution Flow of DSL",id:"main-execution-flow-of-dsl",level:2},{value:"Two-level DAG Physical Execution Plan",id:"two-level-dag-physical-execution-plan",level:2}];function d(e){const t={a:"a",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"dsl-principle-introduction",children:"DSL Principle Introduction"})}),"\n",(0,i.jsx)(t.h2,{id:"geaflow-dsl-architecture",children:"GeaFlow DSL Architecture"}),"\n",(0,i.jsx)(t.p,{children:"The overall architecture of GeaFlow DSL is shown in the following figure:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"dsl_arch",src:n(543).A+"",width:"2236",height:"532"})}),"\n",(0,i.jsx)(t.p,{children:"DSL Layer is a typical compiler technology architecture, which consists of syntax analysis, semantic analysis, intermediate code generation (IR), code optimization, and target code generation (OBJ)."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Language Design"}),": GeaFlow has designed a fusion syntax of SQL+GQL to address the demand for integrated analysis of graphs and tables."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Syntax Analysis"}),": By extending the SqlNode and SqlOperator of ",(0,i.jsx)(t.a,{href:"https://calcite.apache.org/",children:"Calcite"}),", GeaFlow implements a syntax parser for SQL+GQL, generating unified syntax tree information."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Semantic Analysis"}),": By extending the Scope and Namespace of Calcite, GeaFlow implements a custom Validator to perform constraint semantic checks on the syntax tree."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Intermediate Code Generation"}),": By extending the RelNode of Calcite, GeaFlow implements Logical RelNode on the graph for the intermediate representation of GQL syntax."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Code Optimization"}),": The optimizer implements a large number of optimization rules (RBO) to improve execution performance, and may introduce CBO in the future."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Target Code Generation"}),": The code generator Converter is responsible for converting Logical RelNode to Physical RelNode, which is the target code. Physical RelNode can be directly translated into API calls on the graph or table."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Custom Functions"}),": GeaFlow provides a wide range of built-in system functions, and users can also register custom functions as needed."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Custom Plugins"}),": GeaFlow allows users to extend their own Connector types to support different data sources and data formats."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"main-execution-flow-of-dsl",children:"Main Execution Flow of DSL"}),"\n",(0,i.jsxs)(t.p,{children:["The main execution flow of DSL is illustrated in the following figure:\n",(0,i.jsx)(t.img,{alt:"dsl_workflow",src:n(9899).A+"",width:"1598",height:"450"}),"\nThe DSL text is first parsed by the Parser to generate the AST syntax tree, and then the Validator performs semantic checking and type inference to generate a validated AST syntax tree. The graph-logic execution plan is then generated by the Logical Plan transformer. The logical execution plan is optimized by the Optimizer to generate an optimized logical execution plan. The physical execution plan is then generated by the Physical Plan transformer, and the physical execution logic is generated by the DAG Builder. GeaFlow DSL uses a two-level DAG structure to describe the physical execution logic of the flowchart."]}),"\n",(0,i.jsx)(t.h2,{id:"two-level-dag-physical-execution-plan",children:"Two-level DAG Physical Execution Plan"}),"\n",(0,i.jsxs)(t.p,{children:["Unlike traditional distributed table data processing engines such as Storm, Flink, and Spark, GeaFlow is a flowchart-integrated distributed computing system. Its physical execution plan uses a two-level DAG structure for the flowchart, as shown in the following figure:\n",(0,i.jsx)(t.img,{alt:"dsl_twice_level_dag",src:n(844).A+"",width:"1044",height:"626"}),"\nThe outer layer DAG contains operator for table processing and iterative operator for graph processing, which is the main part of the physical execution logic and links the computing logic of the flowchart. The inner DAG expands the graph computation logic through the DAG, representing the specific execution of graph iterative computation."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},9899:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/dsl_workflow-d34bad87573d32733015a5406ca17b8c.png"}}]);