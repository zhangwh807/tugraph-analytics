"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1232],{358:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/framework_failover-2d70f7410d0ce11cbd020578d308d037.jpeg"},575:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=t(4848),o=t(8453);const r={},s="Framework Architecture",a={id:"concepts/framework_principle",title:"Framework Architecture",description:"The architecture of GeaFlow Framework is shown in the following diagram:",source:"@site/../docs-en/source/4.concepts/3.framework_principle.md",sourceDirName:"4.concepts",slug:"/concepts/framework_principle",permalink:"/tugraph-analytics/en/concepts/framework_principle",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"DSL Principle Introduction",permalink:"/tugraph-analytics/en/concepts/dsl_principle"},next:{title:"Introduction to State Principles",permalink:"/tugraph-analytics/en/concepts/state_principle"}},c={},d=[{value:"Computing Engine",id:"computing-engine",level:2},{value:"Execution Plan",id:"execution-plan",level:3},{value:"Scheduling Model",id:"scheduling-model",level:3},{value:"Runtime Execution",id:"runtime-execution",level:3},{value:"Overall Introduction",id:"overall-introduction",level:4},{value:"Command Event",id:"command-event",level:4},{value:"Fault Tolerance And Exception Recovery",id:"fault-tolerance-and-exception-recovery",level:3},{value:"Cluster Component Fault Tolerance",id:"cluster-component-fault-tolerance",level:4},{value:"Job Exception Recovery",id:"job-exception-recovery",level:4}];function l(e){const n={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"framework-architecture",children:"Framework Architecture"})}),"\n",(0,i.jsx)(n.p,{children:"The architecture of GeaFlow Framework is shown in the following diagram:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"framework_arch",src:t(7472).A+"",width:"2236",height:"674"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"High Level API"}),": GeaFlow adapts to heterogeneous distributed execution environments (K8S, Ray, Local) through the Environment interface. It encapsulates the user's data processing flow using Pipelines and abstracts the stream processing (unbounded window) and batch processing (bounded window) using Windows. The Graph interface provides computation APIs on static graphs and dynamic graphs (streaming graphs), such as append/snapshot/compute/traversal, while the Stream interface provides unified stream and batch processing APIs, such as map/reduce/join/keyBy, etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logical Execution Plan"}),": The logical execution plan information is encapsulated in the PipelineGraph object. It organizes the high-level API operators in a directed acyclic graph. Operators are categorized into 5 types: SourceOperator for data source loading, OneInputOperator/TwoInputOperator for traditional data processing, and IteratorOperator for static/dynamic graph computation. The vertices (PipelineVertex) in the DAG store crucial information about operators, such as type, parallelism, and operator functions, while the edges (PipelineEdge) record key information about data shuffling, such as partition rules (forward/broadcast/key), and encoders/decoders."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physical Execution Plan"}),": The physical execution plan information is encapsulated in the ExecutionGraph object, which supports a two-level nested structure to schedule subgraphs that can be executed in pipelined manner. The example execution plan DAG in the graph is partitioned into three subgraph structures for execution."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Scheduler"}),": GeaFlow designs a Cycle-based scheduler (CycleScheduler) to achieve unified scheduling for stream, batch, and graph processing. The scheduling process is triggered by an event-driven model. Each subgraph in the physical execution plan is transformed into an ExecutionCycle object. The scheduler sends events to the head node (Head) of the cycle and receives events sent back from the tail node (Tail) to form a complete scheduling loop. For stream processing, each cycle scheduling round completes the processing of a window of data and continues indefinitely. For batch processing, the entire cycle scheduling is executed only once. For graph processing, each cycle scheduling round completes one iteration of graph computation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Runtime Components"}),": GeaFlow's runtime launches the Client, Master, Driver, and Container components. When the Client submits a Pipeline to the Driver, it triggers the construction of the execution plan, task allocation (resources are provided by ResourceManagement), and scheduler. Each Container can run multiple Worker components, and data exchange between different Worker components is done through the Shuffle module. All workers need to regularly send heartbeats (HeartbeatManagement) to the Master and report runtime metric information to the time-series database. Additionally, GeaFlow's runtime provides fault tolerance mechanisms (FailOver) to continue execution in case of exceptions/interruptions."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"computing-engine",children:"Computing Engine"}),"\n",(0,i.jsx)(n.p,{children:"The core modules of GeaFlow computing engine mainly include execution plan generation and optimization, unified cycle scheduling, and worker runtime execution. The following is an introduction to these core modules."}),"\n",(0,i.jsx)(n.h3,{id:"execution-plan",children:"Execution Plan"}),"\n",(0,i.jsx)(n.p,{children:"For the submitted PipelineTask in the stream graph scenario, a unified execution plan model is constructed, and different execution modes are aggregated together as a group for scheduling to provide a unified execution unit."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"PipelineGraph\nThe PipelineGraph is constructed from the PipelineTask submitted by the user's API. The user's API is transformed into an operator corresponding to a vertex, and the data dependencies between vertices are represented by edges. The PipelineGraph only constructs a structured logical execution plan from the API and does not have the physical execution semantics."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["ExecutionGraph\nThe ExecutionGraph aggregates a group of executable vertices together to build the corresponding ExecutionGroup based on different calculation models. Each group represents an independent schedulable unit. A group can be built from one or more vertices and can be considered as a small execution plan. The data exchange within the group is done in pipeline mode, while batch mode is used between groups. The group describes the specific execution mode, supports nesting, can be executed once or multiple times, and can execute data from one or more windows. The group is shown in the following figure. ExecutionGroup is ultimately transformed into the basic unit cycle for scheduling and execution.\n",(0,i.jsx)(n.img,{alt:"group.jpg",src:t(4380).A+"",width:"531",height:"862"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scheduling-model",children:"Scheduling Model"}),"\n",(0,i.jsx)(n.p,{children:"Scheduling generates scheduling basic units cycles based on ExecutionGroup defined in ExecutionGraph. A cycle is a basic unit that can be executed repeatedly and contains descriptions of input, intermediate calculations, data exchange, and output. The scheduling and execution process is mainly as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Divide the execution plan into a group of cycles. If there is no data dependency between cycles, they can be executed in series or in parallel."}),"\n",(0,i.jsx)(n.li,{children:"According to the scheduling data policy of the cycle, the cycle is scheduled and executed in order."}),"\n",(0,i.jsxs)(n.li,{children:['Wait until all cycles are executed, and return the scheduling execution results.\nEach cycle contains a group of executable ExecutionTasks, and each task can be distributed for remote execution. All execution tasks in a cycle can be divided as follows:\nHead task: the starting point of the cycle data stream. The scheduling sends an execution event to the head task, reads data from the source or the output of the previous cycle, processes it, and sends it to the downstream.\nTail task: the end of the cycle data stream. After processing the data, the tail task sends an event to the scheduler, indicating that a round of calculation is completed.\nOther non-head/tail tasks: intermediate execution tasks that receive input data from upstream, process it, and send it directly to the downstream.\nThe scheduling and execution process of the cycle is like a "loop," continuously sending events to the head and receiving return events from the tail, as shown in the following figure. The scheduling initializes the scheduling state according to the type of the cycle, and the scheduling process is also a process of state transition. Based on the received event, the scheduling decides the type of event to be sent to the head for the next round.\n',(0,i.jsx)(n.img,{alt:"scheduler.jpg",src:t(1195).A+"",width:"850",height:"906"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"runtime-execution",children:"Runtime Execution"}),"\n",(0,i.jsx)(n.h4,{id:"overall-introduction",children:"Overall Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Runtime module is responsible for the specific computation and execution of all GeaFlow mode tasks, including streaming-batch, static/dynamic graph. Its entire worker process is as follows:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Scheduler is responsible for sending various types of events to Container for processing."}),"\n",(0,i.jsx)(n.li,{children:"Dispatcher (inherited from AbstractTaskRunner) is responsible for receiving events sent by Scheduler and distributing them to specified TaskRunners according to their workerId."}),"\n",(0,i.jsxs)(n.li,{children:["TaskRunner (also inherited from AbstractTaskRunner) is responsible for fetching TASK(Event) from taskQueue, and the specific Event will be processed by Task. The whole lifecycle of Task includes creation, processing and ending. For abnormal Tasks, they can be directly interrupted.\na. Task creation and initialization will be completed according to CreateTaskEvent. The lifecycle of Task will end according to DestroyTaskEvent.\nb. Other types of events will be completed on the semantic level of specific calculation through execute() method of corresponding CommandEvent. For example, according to InitCycleEvent, Worker will build upstream and downstream dependencies. According to LaunchSourceEvent, Worker will trigger source to start reading data, etc.\n",(0,i.jsx)(n.img,{alt:"undefined",src:t(4412).A+"",width:"779",height:"772"}),"\nThe core data structure in the current TaskContext includes the Worker responsible for executing computations, the FetchService responsible for asynchronous data reading from upstream nodes to downstream, and the EmitterService responsible for outputting data generated by the execution Worker to downstream."]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Worker: mainly responsible for aligning and processing data in the flow graph, and calling back the corresponding DoneEvent to Scheduler after each batch processing, so that Scheduler can perform subsequent scheduling logic according to the DoneEvent."}),"\n",(0,i.jsx)(n.li,{children:"FetchService: responsible for asynchronously pulling data from the upstream channel, and putting it into the worker processing queue through the Listener registered by the worker."}),"\n",(0,i.jsx)(n.li,{children:"EmitterService: responsible for partition writing the data generated by the Worker into the corresponding Channel."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"command-event",children:"Command Event"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Command Events can be divided into two types:\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Normal Command Events, which do not have specific execute logic and are usually used to trigger the start and end of Task or Cycle lifecycles."}),"\n",(0,i.jsx)(n.li,{children:"Executable Command Events, which have their own execute logic, such as Cycle initialization, data reading in the Source node, computation in the processing node, and cleanup after the Cycle ends."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"In the scheduling module, various types of events will be constructed into a State Machine for the lifecycle management of the entire scheduling task."}),"\n",(0,i.jsx)(n.li,{children:"Developers can extend Events and implement corresponding execute logic according to design needs, and add them to the State Machine. Then Scheduler can automatically schedule and execute them as expected."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"fault-tolerance-and-exception-recovery",children:"Fault Tolerance And Exception Recovery"}),"\n",(0,i.jsx)(n.h4,{id:"cluster-component-fault-tolerance",children:"Cluster Component Fault Tolerance"}),"\n",(0,i.jsx)(n.p,{children:"For all runtime component processes, such as master/driver/container, they are initialized and run based on context. When creating a new process, the context required by the process is constructed first, and each process persists the context during initialization. When a process restarts abnormally, the context is recovered first, and then the process is re-initialized based on the context."}),"\n",(0,i.jsx)(n.h4,{id:"job-exception-recovery",children:"Job Exception Recovery"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"undefined",src:t(358).A+"",width:"955",height:"817"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Distributed snapshot of job\nThe Scheduler determines the new windowId to be sent to the running tasks based on its current scheduling state, triggering the computation of the new window. When each operator completes the calculation of the corresponding window, if a snapshot of the current window context needs to be taken, the corresponding state within the operator will be persisted to storage.\nFinally, after the Scheduler receives the message that all tasks for a certain window have completed, it will take a snapshot of the scheduling metadata as needed and persist it. Only then is the processing of this window considered finished. When the Scheduler and the operator recover to this window context, they can continue to execute based on that window."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Snapshot persistence\nWhen a snapshot is taken after a window calculation is completed, the storage method for the snapshot can be chosen. Currently, MEMORY, ROCKSDB, and JDBC are available."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"State recovery\nThe snapshot storage is distributed, with each component, Scheduler, and operator storing and persisting their own data. During recovery, the Scheduler first recovers the windowId that was last completed from the storage, and then the Scheduler context is restored to the snapshot corresponding to that windowId. Then, a rollback command is sent to all workers, and each worker is restored to the specified window context. Finally, the Scheduler begins sending execution tasks again, continuing to execute based on the recovered state."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1195:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/framework_cyle-39d7a5210e7f041319d7da93a263c84f.jpeg"},4380:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/framework_dag-79bc6c714140a269c92391ae58ab3c8e.jpeg"},4412:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/framework_scheduler-49a78ec34bdc932f5db2e0868a5a88a0.png"},7472:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/framework_arch_new-b50a6933a6a3c01de60ba7cc4e848c9f.png"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);