"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1782],{5460:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(4848),r=t(8453);const i={},s=void 0,o={id:"concepts/stream_graph",title:"stream_graph",description:"Fundamental Conception",source:"@site/../docs-en/source/4.concepts/stream_graph.md",sourceDirName:"4.concepts",slug:"/concepts/stream_graph",permalink:"/tugraph-analytics/en/concepts/stream_graph",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},c={},p=[{value:"Fundamental Conception",id:"fundamental-conception",level:2},{value:"Functional Description",id:"functional-description",level:2},{value:"Example Introduction",id:"example-introduction",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"#Stream Graph"}),"\n",(0,a.jsx)(n.h2,{id:"fundamental-conception",children:"Fundamental Conception"}),"\n",(0,a.jsx)(n.p,{children:'The term "Streaming Graph" refers to graph data that is stream-based, dynamic, and constantly changing. Within the context of GeaFlow, Streaming Graph also refers to the computing mode for streaming graphs, Which is designed for graphs that undergo streaming changes, and performs operations such as graph traversal, graph matching, and graph computation based on graph changes.'}),"\n",(0,a.jsx)(n.p,{children:"Based on the GeaFlow framework, it is easy to perform dynamic computation on streaming graphs. In GeaFlow, we have abstracted two core concepts: Dynamic Graph and Static Graph."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Static Graph refers to a static graph, in which the nodes and edges are fixed at a certain point in time and do not change. Computation on Static Graph is based on the static structure of the entire graph, so conventional graph algorithms and processing can be used for computation."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Dynamic Graph refers to a dynamic graph, where nodes and edges are constantly changing. When the status of a node or edge changes, Dynamic Graph updates the graph structure promptly and performs computation on the new graph structure. In Dynamic Graph, nodes and edges can have dynamic attributes, which can also change with the graph. Computation on Dynamic Graph is based on the real-time structure and attributes of the graph, so special algorithms and processing are required for computation."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"GeaFlow provides various computation modes and algorithms based on Dynamic Graph and Static Graph to facilitate users' choices and usage based on different needs. At the same time, GeaFlow also supports custom algorithms and processing, so users can extend and optimize algorithms according to their own needs."}),"\n",(0,a.jsx)(n.h2,{id:"functional-description",children:"Functional Description"}),"\n",(0,a.jsx)(n.p,{children:"Streaming Graph mainly has the following features:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Supports streaming processing of node and edge data, but the overall graph is static."}),"\n",(0,a.jsx)(n.li,{children:"Supports continuous updates and queries of the graph structure, and can handle incremental data processing caused by changes in the graph structure."}),"\n",(0,a.jsx)(n.li,{children:"Supports backtracking history and can be queried based on historical snapshots."}),"\n",(0,a.jsx)(n.li,{children:"Supports the calculation logic order of the graph, such as the time sequence of edges."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Through real-time graph data flow and changes, Streaming Graph can dynamically implement graph calculations and analysis, and has a wide range of applications. For example, in the fields of social network analysis, financial risk control, and Internet of Things data analysis, Streaming Graph has broad applications prospects."}),"\n",(0,a.jsx)(n.h2,{id:"example-introduction",children:"Example Introduction"}),"\n",(0,a.jsx)(n.p,{children:"When building a Streaming Graph, a new node and edge can be added to the graph continuously through an incremental data stream, thus dynamically constructing the graph. At the same time, for each incremental data graph construction completion, it can trigger traversal calculation tracking the evolving process of Bob's 2-degree friends over time."}),"\n",(0,a.jsx)(n.p,{children:"DSL code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-SQL",children:"\nset geaflow.dsl.window.size = 1;\n\nCREATE TABLE table_knows (\n  personId int,\n  friendId int,\n  weight int\n) WITH (\n  type='file',\n  geaflow.dsl.file.path = 'resource:///data/table_knows.txt'\n);\n\nINSERT INTO social_network.knows\nSELECT personId, friendId, weight\nFROM table_knows;\n\nCREATE TABLE result (\n  personName varchar,\n  friendName varchar,\n  weight int\n) WITH (\n\ttype='console'\n);\n\n-- Graph View Name Defined in Graph View Concept --\nUSE GRAPH social_network;\n-- find person id 3's known persons triggered every window.\nINSERT INTO result\nSELECT\n\tname,\n\tknown_name,\n\tweight\nFROM (\n  MATCH (a:person where a.name = 'Bob') -[e:knows]->{1, 2}(b)\n  RETURN a.name as name, b.name as known_name, e.weight as weight\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"HLA code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"//build graph view.\nfinal String graphName = \"social_network\";\nGraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName).build();\npipeline.withView(graphName, graphViewDesc);\n\n// submit pipeLine task.\npipeline.submit(new PipelineTask() {\n\t@Override\n\tpublic void execute(IPipelineTaskContext pipelineTaskCxt) {\n\n        // build vertices streaming source.\n\t\tPStreamSource<IVertex<Integer, String>> persons =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource.(getVertices()), SizeTumblingWindow.of(5000));\n\t\t// build edges streaming source.\n\t\tPStreamSource<IEdge<Integer, Integer>> knows =\n\t\t\tpipelineTaskCxt.buildSource(\n\t\t\t\tnew CollectionSource<>(getEdges()), SizeTumblingWindow.of(5000));\n\t\t// build graphview by graph name.\n\t\tPGraphView<Integer, String, Integer> socialNetwork =\n\t\t\tpipelineTaskCxt.buildGraphView(graphName);\n\t\t// incremental build graph view.\n\t\tPIncGraphView<Integer, String, Integer> incSocialNetwor =\n\t\t\tsocialNetwork.appendGraph(vertices, edges);\n\n\t\t// traversal by 'Bob'.\n\t\tincGraphView.incrementalTraversal(new IncGraphTraversalAlgorithms(2))\n\t\t\t.start('Bob')\n\t\t\t.map(res -> String.format(\"%s,%s\", res.getResponseId(), res.getResponse()))\n\t\t\t.sink(new ConsoleSink<>());\n\t}\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);