"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7279],{7524:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=t(4848),i=t(8453);const a={},o="Graph Compute Introduction",s={id:"application-development/api/graph/compute",title:"Graph Compute Introduction",description:"GeaFlow provides interfaces for implementing graph computing algorithms, and static or dynamic graph computing can be performed by implementing the corresponding interfaces. Users can define specific computing logic and maximum iteration times in the compute algorithm.",source:"@site/../docs-en/source/5.application-development/1.api/3.graph/2.compute.md",sourceDirName:"5.application-development/1.api/3.graph",slug:"/application-development/api/graph/compute",permalink:"/tugraph-analytics/en/application-development/api/graph/compute",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Graph Traversal Introduction",permalink:"/tugraph-analytics/en/application-development/api/graph/traversal"},next:{title:"Hybrid-DSL Introduction",permalink:"/tugraph-analytics/en/application-development/dsl/overview"}},c={},p=[{value:"Dynamic Graph",id:"dynamic-graph",level:2},{value:"Interface",id:"interface",level:3},{value:"Example",id:"example",level:3},{value:"Static Graph",id:"static-graph",level:2},{value:"Interface",id:"interface-1",level:3},{value:"Example",id:"example-1",level:3}];function l(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"graph-compute-introduction",children:"Graph Compute Introduction"})}),"\n",(0,r.jsx)(n.p,{children:"GeaFlow provides interfaces for implementing graph computing algorithms, and static or dynamic graph computing can be performed by implementing the corresponding interfaces. Users can define specific computing logic and maximum iteration times in the compute algorithm."}),"\n",(0,r.jsx)(n.h2,{id:"dynamic-graph",children:"Dynamic Graph"}),"\n",(0,r.jsx)(n.h3,{id:"interface",children:"Interface"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"API"}),(0,r.jsx)(n.th,{children:"Interface Description"}),(0,r.jsx)(n.th,{children:"Input Parameter Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void init(IncGraphComputeContext<K, VV, EV, M> incGraphContext)"}),(0,r.jsx)(n.td,{children:"Graph computing initialization interface"}),(0,r.jsx)(n.td,{children:"incGraphContext: Context for incremental dynamic graph computing, where K represents the type of vertex ID, VV represents the type of vertex value, EV represents the type of edge value, and M represents the type of message to be sent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph)"}),(0,r.jsx)(n.td,{children:"First round iteration for incremental graph processing logic implementation"}),(0,r.jsxs)(n.td,{children:["vertexId: The ID of the current vertex point, where K represents the type of vertex ID ",(0,r.jsx)(n.br,{}),"temporaryGraph: Temporary incremental graph, where K represents the type of vertex ID, VV represents the type of vertex value, and EV represents the type of edge value"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void compute(K vertexId, Iterator messageIterator)"}),(0,r.jsx)(n.td,{children:"Iterative computing interface"}),(0,r.jsx)(n.td,{children:"vertexId: The ID of the current computation point, where K represents the type of vertex ID"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph)"}),(0,r.jsx)(n.td,{children:"Iterative computing complete interface"}),(0,r.jsxs)(n.td,{children:["vertexId: The ID of the current computation vertex, where K represents the type of vertex ID ",(0,r.jsx)(n.br,{}),"mutableGraph: Mutable graph, where K represents the type of vertex ID, VV represents the type of vertex value, and EV represents the type of edge value"]})]})]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Detailed interface"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"\npublic interface IncVertexCentricFunction<K, VV, EV, M> extends Function {\n\n   void evolve(K vertexId, TemporaryGraph<K, VV, EV> temporaryGraph);\n\n   void compute(K vertexId, Iterator<M> messageIterator);\n\n   void finish(K vertexId, MutableGraph<K, VV, EV> mutableGraph);\n\n   interface IncGraphContext<K, VV, EV, M> {\n       /** Get job id. */\n       long getJobId();\n\n        /** Get the current iterartion id. */\n        long getIterationId();\n        \n        /** Get the runtime context. */\n        RuntimeContext getRuntimeContext();\n\n        /** Get the mutable graph. */\n        MutableGraph<K, VV, EV> getMutableGraph();\n\n    \t/** Get the temporary graph. */\n        TemporaryGraph<K, VV, EV> getTemporaryGraph();\n\n        /** Get the historical graph. */\n        HistoricalGraph<K, VV, EV> getHistoricalGraph();\n\n        /** Send message to specified vertex. */\n        void sendMessage(K vertexId, M message);\n\n        /** Send message to neighbors of current vertex. */\n        void sendMessageToNeighbors(M message);\n\n   }\n\n   interface TemporaryGraph<K, VV, EV> {\n   /** Get vertex from temporary graph. */\n   IVertex<K, VV> getVertex();\n\n        /** Get the edges from incremental graph. */\n        List<IEdge<K, EV>> getEdges();\n\n        /** Update vertex value. */\n        void updateVertexValue(VV value);\n\n   }\n\n   interface HistoricalGraph<K, VV, EV> {\n   /** Get the latest version id of graph state. */\n   Long getLatestVersionId();\n\n        /** Get all versions of graph state. */\n        List<Long> getAllVersionIds();\n\n        /** Get all vertices. */\n        Map<Long, IVertex<K, VV>> getAllVertex();\n\n        /** Get the all vertices of specified version. */\n        Map<Long, IVertex<K, VV>> getAllVertex(List<Long> versions);\n\n        /** Get vertices of the graph data of a specified version that meet the filtering condition. */\n        Map<Long, IVertex<K, VV>> getAllVertex(List<Long> versions, IVertexFilter<K, VV> vertexFilter);\n\n        /** Get snapshot of the graph data of a specified version. */\n        GraphSnapShot<K, VV, EV> getSnapShot(long version);\n\n   }\n\n   interface GraphSnapShot<K, VV, EV> {\n   /** Get the current version id. */\n   long getVersion();\n   /** Get vertex. */\n   VertexQuery<K, VV> vertex();\n   /** Get edges. */\n   EdgeQuery<K, EV> edges();\n\n   }\n\n   interface MutableGraph<K, VV, EV> {\n   /** Add a vertex to the graph and specify its version ID. */\n   void addVertex(long version, IVertex<K, VV> vertex);\n   /** Add a edge to the graph and specify its version ID. */\n   void addEdge(long version, IEdge<K, EV> edge);\n\n   }\n\n\n}\n\npublic interface IncVertexCentricComputeFunction<K, VV, EV, M> extends\n        IncVertexCentricFunction<K, VV, EV, M> {\n\n    void init(IncGraphComputeContext<K, VV, EV, M> incGraphContext);\n\n    interface IncGraphComputeContext<K, VV, EV, M> extends IncGraphContext<K, VV, EV, M> {\n        void collect(IVertex<K, VV> vertex);\n    }\n\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class IncrGraphCompute {\n\n   private static final Logger LOGGER = LoggerFactory.getLogger(IncrGraphCompute.class);\n\n   public static void main(String[] args) {\n      Environment environment = EnvironmentFactory.onLocalEnvironment();\n      IPipelineResult result = submit(environment);\n      result.get();\n      environment.shutdown();\n   }\n\n   public static IPipelineResult<?> submit(Environment environment) {\n      final Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n      final String graphName = "graph_view_name";\n      GraphViewDesc graphViewDesc = GraphViewBuilder.createGraphView(graphName)\n              .withShardNum(4)\n              .withBackend(BackendType.RocksDB)\n              .withSchema(new GraphMetaType(IntegerType.INSTANCE, ValueVertex.class, Integer.class, ValueEdge.class, IntegerType.class))\n              .build();\n      pipeline.withView(graphName, graphViewDesc);\n      pipeline.submit(new PipelineTask() {\n         @Override\n         public void execute(IPipelineTaskContext pipelineTaskCxt) {\n            Configuration conf = pipelineTaskCxt.getConfig();\n            PWindowSource<IVertex<Integer, Integer>> vertices =\n                    // Extract vertex from edge file.\n                    pipelineTaskCxt.buildSource(new RecoverableFileSource<>("data/input/email_edge",\n                            line -> {\n                               String[] fields = line.split(",");\n                               IVertex<Integer, Integer> vertex1 = new ValueVertex<>(\n                                       Integer.valueOf(fields[0]), 1);\n                               IVertex<Integer, Integer> vertex2 = new ValueVertex<>(\n                                       Integer.valueOf(fields[1]), 1);\n                               return Arrays.asList(vertex1, vertex2);\n                            }), SizeTumblingWindow.of(10000));\n\n            PWindowSource<IEdge<Integer, Integer>> edges =\n                    pipelineTaskCxt.buildSource( new RecoverableFileSource<>("data/input/email_edge",\n                            line -> {\n                               String[] fields = line.split(",");\n                               IEdge<Integer, Integer> edge = new ValueEdge<>(Integer.valueOf(fields[0]),\n                                       Integer.valueOf(fields[1]), 1);\n                               return Collections.singletonList(edge);\n                            }), SizeTumblingWindow.of(5000));\n\n            PGraphView<Integer, Integer, Integer> fundGraphView = pipelineTaskCxt.getGraphView(graphName);\n\n            PIncGraphView<Integer, Integer, Integer> incGraphView = fundGraphView.appendGraph(vertices, edges);\n            incGraphView.incrementalCompute(new IncGraphAlgorithms(3))\n                    .getVertices()\n                    .map(v -> String.format("%s,%s", v.getId(), v.getValue()))\n                    .sink(v -> {\n                       LOGGER.info("result: {}", v);\n                    });\n         }\n      });\n      return pipeline.execute();\n   }\n\n\n   public static class IncGraphAlgorithms extends IncVertexCentricCompute<Integer, Integer, Integer, Integer> {\n      public IncGraphAlgorithms(long iterations) {\n         super(iterations);\n      }\n\n      @Override\n      public IncVertexCentricComputeFunction<Integer, Integer, Integer, Integer> getIncComputeFunction() {\n         return new IncVertexCentricComputeFunction<Integer, Integer, Integer, Integer>() {\n            private IncGraphComputeContext<Integer, Integer, Integer, Integer> graphContext;\n\n            @Override\n            public void init(IncGraphComputeContext<Integer, Integer, Integer, Integer> graphContext) {\n               this.graphContext = graphContext;\n            }\n            @Override\n            public void evolve(Integer vertexId,\n                               TemporaryGraph<Integer, Integer, Integer> temporaryGraph) {\n               IVertex<Integer, Integer> vertex = temporaryGraph.getVertex();\n               if (vertex != null) {\n                  if (temporaryGraph.getEdges() != null) {\n                     for (IEdge<Integer, Integer> edge : temporaryGraph.getEdges()) {\n                        graphContext.sendMessage(edge.getTargetId(), vertexId);\n                     }\n                  }\n               }\n            }\n\n            @Override\n            public void compute(Integer vertexId, Iterator<Integer> messageIterator) {\n               int max = 0;\n               while (messageIterator.hasNext()) {\n                  int value = messageIterator.next();\n                  max = Math.max(max, value);\n               }\n               graphContext.getTemporaryGraph().updateVertexValue(max);\n            }\n\n            @Override\n            public void finish(Integer vertexId, MutableGraph<Integer, Integer, Integer> mutableGraph) {\n               IVertex<Integer, Integer> vertex = graphContext.getTemporaryGraph().getVertex();\n               graphContext.collect(vertex);\n            }\n         };\n      }\n      @Override\n      public VertexCentricCombineFunction<Integer> getCombineFunction() {\n         return null;\n      }\n\n   }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"static-graph",children:"Static Graph"}),"\n",(0,r.jsx)(n.h3,{id:"interface-1",children:"Interface"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"API"}),(0,r.jsx)(n.th,{children:"Interface Description"}),(0,r.jsx)(n.th,{children:"Input Parameter Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void init(VertexCentricComputeFuncContext<K, VV, EV, M> vertexCentricFuncContext)"}),(0,r.jsx)(n.td,{children:"Iterative computing initialization interface"}),(0,r.jsx)(n.td,{children:"vertexCentricFuncContext: Context for static graph computing, where K represents the type of vertex ID, VV represents the type of vertex value, EV represents the type of edge value, and M represents the type of message to be sent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void compute(K vertexId, Iterator messageIterator)"}),(0,r.jsx)(n.td,{children:"Iterative computing interface"}),(0,r.jsxs)(n.td,{children:["vertexId: The ID of the current computation vertex, where K represents the type of vertex ID ",(0,r.jsx)(n.br,{}),"messageIterator: All messages sent to the current vertex during iteration, where M represents the type of message defined during iterative computing"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"void finish()"}),(0,r.jsx)(n.td,{children:"Iterative computing complete interface"}),(0,r.jsx)(n.td,{children:"no"})]})]})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Detailed interface"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface VertexCentricComputeFunction<K, VV, EV, M> extends VertexCentricFunction<K, VV,\nEV, M> {\n\n    void init(VertexCentricComputeFuncContext<K, VV, EV, M> vertexCentricFuncContext);\n\n    void compute(K vertex, Iterator<M> messageIterator);\n\n    void finish();\n\n    interface VertexCentricComputeFuncContext<K, VV, EV, M> extends VertexCentricFuncContext<K, VV,\n        EV, M> {\n    \t/** Set new vertex value. */\n        void setNewVertexValue(VV value);\n\n    }\n\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class StaticsGraphCompute {\n    \n    public static void main(String[] args) {\n      \tEnvironment environment = EnvironmentFactory.onLocalEnvironment();\n        IPipelineResult result = submit(environment);\n        result.get();\n        environment.shutdown();\n    }\n\n    public static IPipelineResult<?> submit(Environment environment) {\n        Pipeline pipeline = PipelineFactory.buildPipeline(environment);\n\n        pipeline.submit((PipelineTask) pipelineTaskCxt -> {\n            PWindowSource<IVertex<Integer, Integer>> prVertices =\n                pipelineTaskCxt.buildSource(new FileSource<>("data/input/email_vertex",\n                    line -> {\n                        String[] fields = line.split(",");\n                        IVertex<Integer, Integer> vertex = new ValueVertex<>(\n                            Integer.valueOf(fields[0]), Integer.valueOf(fields[1]));\n                        return Collections.singletonList(vertex);\n                    }), AllWindow.getInstance())\n                    .withParallelism(2);\n\n            PWindowSource<IEdge<Integer, Integer>> prEdges = pipelineTaskCxt.buildSource(new FileSource<>(\n                "data/input/email_edge", line -> {\n                String[] fields = line.split(",");\n                IEdge<Integer, Integer> edge = new ValueEdge<>(Integer.valueOf(fields[0]), Integer.valueOf(fields[1]), 1);\n                return Collections.singletonList(edge);\n            }), AllWindow.getInstance()).withParallelism(2);\n\n            GraphViewDesc graphViewDesc = GraphViewBuilder\n                .createGraphView(GraphViewBuilder.DEFAULT_GRAPH)\n                .withShardNum(2)\n                .withBackend(BackendType.Memory)\n                .build();\n            \n            PGraphWindow<Integer, Integer, Integer> graphWindow =\n                pipelineTaskCxt.buildWindowStreamGraph(prVertices, prEdges, graphViewDesc);\n            graphWindow.compute(new SSSPAlgorithm(1, 10))\n                .compute(2)\n                .getVertices()\n                .sink(v -> {});\n        });\n        return pipeline.execute();\n    }\n    \n    public static class SSSPAlgorithm extends VertexCentricCompute<Integer, Integer, Integer, Integer> {\n\n        private final int srcId;\n        public SSSPAlgorithm(int srcId, long iterations) {\n            super(iterations);\n            this.srcId = srcId;\n        }\n\n        @Override\n        public VertexCentricComputeFunction<Integer, Integer, Integer, Integer> getComputeFunction() {\n            return new VertexCentricComputeFunction<Integer, Integer, Integer, Integer>() {\n                \n                private VertexCentricComputeFuncContext<Integer, Integer, Integer, Integer> context;\n                @Override\n                public void init(VertexCentricComputeFuncContext<Integer, Integer, Integer, Integer> vertexCentricFuncContext) {\n                    this.context = vertexCentricFuncContext;\n                }\n\n                @Override\n                public void compute(Integer vertex, Iterator<Integer> messageIterator) {\n                    int minDistance = vertex == srcId ? 0 : Integer.MAX_VALUE;\n                    if (messageIterator != null) {\n                        while (messageIterator.hasNext()) {\n                            Integer value = messageIterator.next();\n                            minDistance = Math.min(minDistance, value);\n                        }\n                    }\n                    IVertex<Integer, Integer> iVertex = this.context.vertex().get();\n                    if (minDistance < iVertex.getValue()) {\n                        this.context.setNewVertexValue(minDistance);\n                        for (IEdge<Integer, Integer> edge : this.context.edges().getOutEdges()) {\n                            this.context.sendMessage(edge.getTargetId(), minDistance + edge.getValue());\n                        }\n                    }\n                }\n                @Override\n                public void finish() {\n                    \n                }\n            };\n        }\n        @Override\n        public VertexCentricCombineFunction<Integer> getCombineFunction() {\n            return null;\n        }\n    }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(6540);const i={},a=r.createContext(i);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);